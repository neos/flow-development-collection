<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="flow3.objectframework"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xl="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:xhtml="http://www.w3.org/1999/xhtml"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:ns="http://docbook.org/ns/docbook"
         xmlns:mathml="http://www.w3.org/1998/Math/MathML">
  <title>Object Framework</title>

  <para>The lifecycle of objects are managed centrally by the object
  framework. It offers convenient support for Dependency Injection and
  provides some additional features such as a caching mechanism for objects.
  Because all packages are built on this foundation it is important to
  understand the general concept of objects in FLOW3 and the container.</para>

  <tip>
    <para>A very good start to understand the idea of Inversion of Control and
    Dependency Injection is reading <link
    xl:href="http://martinfowler.com/articles/injection.html">Martin Fowler's
    article</link> on the topic.</para>
  </tip>

  <section xml:id="flow3.objectframework.creatingobjects">
    <title>Creating Objects</title>

    <para>In simple, self-contained applications, creating objects is as
    simple as using the <function>new</function> operator. However, as the
    program gets more complex, a developer is confronted with solving
    dependencies to other objects, make classes configurable (maybe through a
    factory method) and finally assure a certain scope for the object (such as
    <firstterm>Singleton</firstterm> or <firstterm>Prototype</firstterm>).
    <personname> <firstname>Howard</firstname> <othername>Lewis</othername>
    <surname>Ship</surname> </personname> explained this circumstances nicely
    in <link
    xl:href="http://tapestryjava.blogspot.com/2004/08/dependency-injection-mirror-of-garbage.html">his
    blog</link> (quite some time ago):</para>

    <blockquote>
      <para>Once you start thinking in terms of large numbers of objects, and
      a whole lot of just in time object creation and configuration, the
      question of <emphasis>how</emphasis> to create a new object doesn't
      change (that's what <function>new</function> is for) ... but the
      questions <emphasis>when</emphasis> and <emphasis>who</emphasis> become
      difficult to tackle. Especially when the <emphasis>when</emphasis> is
      very dynamic, due to just-in-time instantiation, and the
      <emphasis>who</emphasis> is unknown, because there are so many places a
      particular object may be used.</para>
    </blockquote>

    <para>The Object Manager is responsible for object building and dependency
    resolution (we'll discover shortly why dependency injection makes such a
    difference to your application design). In order to fulfill its task, it
    is important that all objects are instantiated only through the object
    framework.</para>

    <section>
      <title>Object Scopes</title>

      <para>Objects live in a specific scope. The most commonly used are
      <emphasis>prototype</emphasis> and
      <emphasis>singleton:</emphasis></para>

      <table>
        <title>Supported scopes</title>

        <tgroup cols="2">
          <colspec colwidth="1*"/>

          <colspec colwidth="3*"/>

          <thead>
            <row>
              <entry align="center">Scope</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>singleton (default)</entry>

              <entry>The object instance is unique during one request - each
              injection by the Object Manager or explicit call of
              <function>getObject</function> returns the same instance. A
              request can be an HTTP request or a run initiated from the
              command line.</entry>
            </row>

            <row>
              <entry>prototype</entry>

              <entry>The object instance is not unique - each injection or
              call of the Object Factory's <function>create</function> method
              returns a fresh instance.</entry>
            </row>

            <row>
              <entry>session<footnote>
                  <remark>Not yet implemented</remark>
                </footnote></entry>

              <entry>The object instance is unique during the whole user
              session - each injection or <function>getObject</function> call
              returns the same instance.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In PHP, objects of the scope prototype are created with the
      <function>new</function> operator:<programlisting language="php">$myFreshObject = new \F3\MyPackage\MyClassName;</programlisting></para>

      <para>In contrast to Prototype, the Singleton design pattern ensures
      that only one instance of a class exists at a time. In PHP the Singleton
      pattern is often implemented by providing a static function (usually
      called <function>getInstance</function>), which returns a unique
      instance of the class:</para>

      <programlisting language="php">/**
 * Implementation of the Singleton pattern
 */
class ASingletonClass {

	protected static $instance;

	static public function getInstance() {
		if (!is_object(self::$instance)) {
			self::$instance = $this;
		}
		return self::$instance;
	}
}</programlisting>

      <para>Although this way of implementing the singleton will possibly not
      conflict with the Object Manager, it is counterproductive to the
      integrity of the system and might raise problems with unit testing
      (sometimes Singleton is referred to as an <emphasis>Anti
      Pattern</emphasis>). The above examples are <emphasis>not
      recommended</emphasis> for the use within FLOW3 applications.</para>

      <para>The scope of an object is determined from its configuration (see
      also: Configuring Objects). The recommended way to specify the scope is
      the <varname>@scope</varname> annotation:</para>

      <programlisting language="php">namespace F3\MyPackage;

/**
 * A sample class
 *
 * @scope prototype
 */
class SomeClass {
}</programlisting>

      <para>Singleton is the default scope and is therefore assumed if no
      <varname>@scope</varname> annotation or other configuration was
      found.</para>
    </section>

    <section>
      <title>Creating Prototypes</title>

      <para>The instantiation of classes must be handled by the object
      framework to assert full control over the object lifecycle. In order to
      instantiate a class or retrieve an existing instance of a class, you'll
      have to call an API function instead of using the
      <function>new</function> operator. To create a fresh instance of an
      object just call the Object Factory's <methodname>create</methodname>
      method:</para>

      <para><programlisting language="php">$myFreshObject = $objectFactory-&gt;create('F3\MyPackage\MyClassName');</programlisting></para>

      <para>The Object Factory
      (<classname>\F3\FLOW3\Object\FactoryInterface</classname>) itself is a
      Singleton and can be acquired like any other object of that scope (see
      next section).</para>

      <para>Analog to <function>new</function> it is possible to pass
      arguments a constructor of the class being instantiated - they are
      simply passed as additional arguments to the
      <methodname>create</methodname> method:</para>

      <para><programlisting language="php">$myFreshObject = $objectFactory-&gt;create('F3\MyPackage\MyClassName', ↩
   'first argument', $secondArgument, 42, $fourthArgument);</programlisting></para>
    </section>

    <section>
      <title>Retrieving Singletons</title>

      <para>The Object Manager maintains a registry of all instantiated
      singletons and ensures that only one instance of each class exists. The
      preferred way to retrieve a singleton object is dependency
      injection:</para>

      <example>
        <title>Retrieving the Object Factory through dependency
        injection</title>

        <programlisting language="php">namespace F3\MyPackage;

/**
 * A sample class
 */
class SampleClass {

	/**
	 * @var \F3\FLOW3\Object\FactoryInterface
	 */
	protected $objectFactory;

	/**
	 * Constructor.
	 * The Object Factory will automatically be passed (injected) by the object 
	 * framework on instantiating this class.
	 *
	 * @param \F3\FLOW3\Object\FactoryInterface $objectFactory The object factory
	 */
	public function __construct(\F3\FLOW3\Object\FactoryInterface $objectFactory) {
		$this-&gt;objectFactory = $objectFactory;
	}
}</programlisting>
      </example>

      <para>Once the <classname>SampleClass</classname> is being instantiated,
      the object framework will automagically pass a reference to the Object
      Factory (which is an object of scope <emphasis>singleton</emphasis>) as
      an argument to the constructor. This kind of dependency injection is
      called <firstterm>Constructor Injection</firstterm> and will be
      explained - together with other kinds of injection - in one of the later
      sections.</para>

      <para>Although dependency injection is what you should strive for, it
      might happen that you need to retrieve object instances directly. The
      <classname>ObjectManager</classname> provides methods for retrieving
      object instances for these rare situations. First, you need an instance
      of the <classname>ObjectManager</classname> itself, again by taking
      advantage of constructor injection:</para>

      <programlisting language="php">public function __construct(\F3\FLOW3\Object\ManagerInterface $objectManager) {
	$this-&gt;objectManager = $objectManager;
}</programlisting>

      <para>To explicitly retrieve an object instance use the
      <function>getObject()</function> method:</para>

      <programlisting language="php">$myObjectInstance = $objectManager-&gt;getObject('F3\MyPackage\MyClassName');</programlisting>

      <para>Like with the <classname>ObjectFactory</classname>'s
      <methodname>create</methodname> method, it is possible to pass arguments
      to the constructor of the object class just by adding them to the
      <function>getObject()</function> call. However passing arguments to a
      Singleton object makes only sense on the first call when the instance is
      actually created. On all consecutive calls the arguments are just
      ignored.</para>
    </section>

    <section>
      <title>Passing constructor arguments</title>

      <para>In most cases an object class will live in the Singleton scope and
      at most requires a few dependencies passed to its constructor. However,
      there are times when it becomes necessary to pass dynamic values as
      constructor arguments, especially when the object represents an entity
      and its instances are not unique (Prototype scope). Consider the
      following classes:</para>

      <example>
        <title>A simple address book</title>

        <programlisting language="php">namespace F3\Address;

/**
 * A simple address book
 */
class AddressBook {

	protected $addresses = array();

	public __construct(\F3\iCal\iCalConnectorInterface $iCalConnector) {
		...
	}

	public addAddress(\F3\Address\Address $address) {
		$this-&gt;addresses[] = $address;
	}
}

/**
 * An address
 *
 * @scope prototype
 */
class Address {

	public __construct($street, $zip, $town, $country) {
		...
	}
}</programlisting>
      </example>

      <para>This is admittedly not the fanciest implementation of an address
      book, but it should demonstrate two things:</para>

      <itemizedlist>
        <listitem>
          <para>The class <classname>\F3\Address\AddressBook</classname> is
          supposed to be a Singleton and obviously depends on a third object
          type <classname>\F3\iCal\iCalConnectorInterface</classname> which is
          possibly solved by Dependency Injection (will be explained in a
          later section).</para>
        </listitem>

        <listitem>
          <para>The class <classname>\F3\Address\Address</classname>
          represents the address entity and its instances must not be unique -
          we surely want more than one address. The Address object also
          expects a few parameters passed to its constructor.</para>
        </listitem>
      </itemizedlist>

      <para>The following code demonstrates how this address book can be used
      and constructor arguments are passed to the Address entity:</para>

      <example>
        <title>Passing constructor arguments</title>

        <programlisting language="php">// Explicitly fetch a unique instance of the address book (but better use 
// Dependency Injection ...):
$myAddressBook = $objectManager-&gt;getObject('F3\Address\AddressBook');

// Create two new addresses and add them to the address book:
$newAddress = $objectFactory-&gt;create('F3\Address\Address', 'Tryggevældevej', ↩
    '2720', 'København', 'DK');
$myAddresbook-&gt;addAddress($newAddress);

$newAddress = $objectFactory-&gt;create('F3\Address\Address', 'An den Brodbänken', ↩
   '21335', 'Lüneburg', 'DE');
$myAddresbook-&gt;addAddress($newAddress);</programlisting>
      </example>
    </section>

    <section>
      <title>Lifecycle methods</title>

      <para>The lifecycle of an object goes through different stages. It boils
      down to the following order:</para>

      <orderedlist>
        <listitem>
          <para>Solve dependencies for constructor injection</para>
        </listitem>

        <listitem>
          <para>Create an instance of the object class</para>
        </listitem>

        <listitem>
          <para>Solve and inject dependencies for setter injection</para>
        </listitem>

        <listitem>
          <para>Live a happy object-life and solve exciting tasks</para>
        </listitem>

        <listitem>
          <para>Dispose the object instance</para>
        </listitem>
      </orderedlist>

      <para>Your object might want to take some action after certain of the
      above steps. Whenever one of the following methods exists in the object
      class, it will be invoked after the related lifecycle step:</para>

      <orderedlist>
        <listitem>
          <para>No action after this step</para>
        </listitem>

        <listitem>
          <para>During instantiation the function
          <function>__construct()</function> is called (by PHP itself),
          dependencies are passed to the constructor arguments</para>
        </listitem>

        <listitem>
          <para>After all dependencies have been injected (through
          constructor- or setter injection) the object's initialization method
          is called. The name of this method is configurable and it is called
          regardless of whether any dependencies have been injected or
          not</para>
        </listitem>

        <listitem>
          <para>During the life of an object no special lifecycle methods are
          called</para>
        </listitem>

        <listitem>
          <para>Before destruction of the object, the function
          <function>shutdownObject</function> is called. The name of this
          method is also configurable.</para>
        </listitem>

        <listitem>
          <para>On disposal, the function <function>__destruct()</function> is
          called (by PHP itself)</para>
        </listitem>
      </orderedlist>

      <para>We strongly recommend that you use the
      <methodname>shutdownObject</methodname> method instead of PHP's
      <methodname>__destruct</methodname> method for shutting down your
      object. If you used <methodname>__destruct</methodname> it might happen
      that important parts of the framework are already unavailable. Here's a
      simple example with all kinds of lifecycle methods:</para>

      <example>
        <title>Sample class with lifecycle methods</title>

        <programlisting language="php">class Foo {

	protected $bar;
	protected $identifier = 'Untitled';

	public function __construct() {
		echo ('Constructing object ...');
	}

	public function injectBar(\F3\MyPackage\BarInterface $bar) {
		$this-&gt;bar = $bar;
	}

	public function setIdentifier($identifier) {
		$this-&gt;identifier = $identifier;
	}

	public function intializeObject() {
		echo ('Initializing object ...');
	}

	public function shutdownObject() {
		echo ('Shutting down object ...')
	}
	
	public function __destruct() {
		echo ('Destructing object ...');
	}
}</programlisting>

        <screen>Constructing object ...
Initializing object ...
Shutting down object ...
Destructing object ...</screen>
      </example>
    </section>
  </section>

  <section xml:id="flow3.objectframework.objectregistration">
    <title>Object Registration and API</title>

    <section>
      <title>Object Framework API</title>

      <para>The object framework provides a lean API for registering,
      configuring and retrieving instances of objects. Some of the methods
      provided are exclusively used within the <package>FLOW3</package>
      package or in unit tests and should possibly not be used elsewhere. By
      offering Dependency Injection, the object framework helps you to avoid
      creating rigid interdependencies between objects and allows for writing
      code which is hardly or even not at all aware of the framework it is
      working in. Calls to the Object Manager should therefore be the
      exception.</para>

      <para>For a list of available methods please refer to the API
      documentation of the interface
      <classname>F3\FLOW3\Object\ManagerInterface</classname>.</para>
    </section>

    <section>
      <title>Object names and types</title>

      <para>By default, the name of an object is identical to the PHP class
      which contains the object's code. A class called
      <classname>F3\MyPackage\MyImplementation</classname> will be
      automatically available as an object with the exact same name. Every
      part of the system which asks for an object with a certain name will
      therefore - by default - get an instance of the class of that name. It
      is possible to replace the original implementation of an object by
      another one. In that case the class name of the new implementation will
      naturally differ from the object name which stays the same at all times.
      In these cases it is important to be aware of the fine difference
      between an object name and a class name.</para>

      <para>If the object name equals the name of a PHP interface, it is often
      referred to as a <emphasis>object type</emphasis>. An interface called
      <interfacename>F3\MyPackage\MyInterface</interfacename> will be
      available as an object of the same name as long as there exists one
      class implementing that interface. Object types can be created and
      retrieved like regular objects:</para>

      <programlisting language="php">$objectTypeInstance = $objectFactory-&gt;create('F3\MyPackage\MyInterface');</programlisting>

      <para>If exactly one class implements the
      <interfacename>F3\SomePackage\SomeInterfaceName</interfacename>
      interface, <varname>$otherObjectInstance</varname> will contain an
      instance of that class. If zero or more than one class implements the
      interface, the Object Factory will throw an exception.</para>

      <para>The advantage of using object types instead of regular object
      names is the increased flexibility: By referring to interfaces rather
      than classes it is possible to write code depending on other classes
      without the need to be specific about the implementation. Which
      implementation will actually be used can be set at a later point in time
      by simple means of configuration.</para>
    </section>
  </section>

  <section xml:id="flow3.objectframework.objectdependencies">
    <title>Object dependencies</title>

    <para>The intention to base an application on a combination of packages
    and objects is to force a clean separation of domains which are realized
    by dedicated objects. The less each object knows about the internals of
    another object, the easier it is to modify or replace one of them, which
    in turn makes the whole system flexible. In a perfect world, each of the
    objects could be reused in a variety of contexts, for example
    independently from certain packages and maybe even outside the FLOW3
    framework.</para>

    <section>
      <title>Dependency Injection</title>

      <para>An important prerequisite for reusable code is already met by
      encouraging encapsulation through object orientation. However, the
      objects are still aware of their environment as they need to actively
      collaborate with other objects and the framework itself: An
      authentication object will need a logger for logging intrusion attempts
      and the code of a shop system hopefully consists of more than just one
      class. Whenever an object refers to another directly, it adds more
      complexity and removes flexibility by opening new interdependencies. It
      is very difficult or even impossible to reuse such hardwired classes and
      it becomes a nightmare testing them.</para>

      <para>By introducing <firstterm>Dependency Injection</firstterm>, these
      interdependencies are minimized by inverting the control over resolving
      the dependencies: Instead of asking for the instance of an object
      actively, the depending object just gets one
      <emphasis>injected</emphasis> by the Object Manager. This methodology is
      also referred to as the "<link
      xl:href="http://en.wikipedia.org/wiki/Hollywood_Principle">Hollywood
      Principle</link>": <quote>Don't call us, we'll call you.</quote>. It
      helps in the development of code with loose coupling and high cohesion –
      or in short: It makes you a better programmer.</para>

      <para>In the context of the previous example it means that the
      authentication object announces that it needs a logger which implements
      a certain PHP interface (e.g. the
      <interfacename>F3\FLOW3\Log\Logger\BackendInterface</interfacename>).
      The object itself has no control over what kind of logger backend
      (file-logger, sms-logger, ...) it finally gets and it doesn't have to
      care about it anyway as long as it matches the expected API. As soon as
      the authentication object is instantiated, the object manager will
      resolve these dependencies, prepare an instance of a logger backend and
      inject it to the authentication object.</para>

      <tip>
        <para><link xl:href="http://www.ddj.com/dept/java/184405016">An
        article</link> by <personname><firstname>Jonathan</firstname>
        <surname>Amsterdam</surname></personname> discusses the difference
        between creating an object and requesting one (i.e. using
        <function>new</function> versus using dependency injection). It
        demonstrates why <function>new</function> should be considered as a
        low-level tool and outlines issues with polymorphism. He doesn't
        mention dependency injection though ...</para>
      </tip>

      <para>Dependencies on other objects can be declared in the object's
      configuration (see section about configuring objects) or they can be
      solved automatically (so called autowiring). Generally there are two
      modes of dependency injection supported by FLOW3: <firstterm>Constructor
      Injection</firstterm> and <firstterm>Setter
      Injection</firstterm>.</para>

      <section>
        <title>Constructor Injection</title>

        <para>With constructor injection, the dependencies are passed as
        constructor arguments to the depending object while it is
        instantiated. Here is an example of an object <classname>Foo
        </classname>which depends on an object
        <classname>Bar</classname>:</para>

        <example>
          <title>A simple example for Constructor Injection</title>

          <programlisting language="php">namespace F3\MyPackage;

class Foo {

	protected $bar;

	public function __construct(\F3\MyPackage\BarInterface $bar) {
		$this-&gt;bar = $bar;
	}

	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting>
        </example>

        <para>So far there's nothing special about this class, it just makes
        sure that an instance of a class implementing the
        <interfacename>\F3\MyPackage\BarInterface</interfacename> is passed to
        the constructor. However, this is already a quite flexible approach
        because the type of <varname>$bar</varname> can be determined from
        outside by just passing one or the another implementation to the
        constructor.</para>

        <para>Now the FLOW3 Object Manager does some magic: By a mechanism
        called <firstterm>Autowiring</firstterm> all dependencies which were
        declared in a constructor will be injected automagically if the
        constructor argument provides a type definition (i.e.
        <classname>\F3\MyPackage\BarInterface</classname> in the above
        example). Autowiring is activated by default (but can be switched
        off), therefore all you have to do is to write your constructor
        method.</para>

        <para>The object framework can also be configured manually to inject a
        certain object or object type. You'll have to do that either if you
        want to switch off autowiring or want to specify a configuration which
        differs from would be done automatically.</para>

        <example>
          <title>Objects.yaml file for Constructor Injection</title>

          <programlisting language="yaml">F3\MyPackage\Foo:
  arguments:
    1: { object: F3\MyPackage\Bar }</programlisting>
        </example>

        <para>The three lines above define that an object instance of
        <interfacename>\F3\MyPackage\Bar</interfacename> must be passed to the
        first argument of the constructor when an instance of the object
        <classname>F3\MyPackage\Foo</classname> is created.</para>
      </section>

      <section>
        <title>Setter Injection</title>

        <para>With setter injection, the dependencies are passed by calling
        <firstterm>setter methods</firstterm> of the depending object right
        after it has been instantiated. Here is an example of the
        <classname>Foo</classname> class which depends on a
        <classname>Bar</classname> object - this time with setter
        injection:</para>

        <example>
          <title>A simple example for Setter Injection</title>

          <programlisting language="php">namespace F3\MyPackage;

class Foo {

	protected $bar;

	public function setBar(\F3\MyPackage\BarInterface $bar) {
		$this-&gt;bar = $bar;
	}

	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting>
        </example>

        <para>Analog to the constructor injection example, a
        <classname>BarInterface</classname> compatible object is injected into
        the authentication object. In this case, however, the injection only
        takes place after the class has been instantiated and a possible
        constructor method has been called. The necessary configuration for
        the above example looks like this:</para>

        <example>
          <title>Objects.yaml file for Setter Injection</title>

          <programlisting language="php">F3\MyPackage\Foo:
  properties:
    bar: { object: F3\MyPackage\BarInterface }</programlisting>
        </example>

        <para>Unlike constructor injection, setter injection like in the above
        example does not offer the autowiring feature. All dependencies have
        to be declared explicitly in the object configuration. To save you
        from writing large configuration files, FLOW3 supports a second type
        of setter methods: By convention all methods whose name start with
        "inject" are considered as setters for setter injection. For those
        methods no further configuration is necessary, dependencies will be
        autowired (if autowiring is not disabled):</para>

        <example>
          <title>The preferred way of Setter Injection, using an inject
          method</title>

          <programlisting language="php">namespace F3\MyPackage;

class Foo {

	protected $bar;

	public function injectBar(\F3\MyPackage\BarInterface $bar) {
		$this-&gt;bar = $bar;
	}

	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting>
        </example>

        <para>Note the new method name <methodname>injectBar</methodname> -
        for the above example no further configuration is required (but
        possible). Using <methodname>inject*</methodname> methods is the
        preferred way for setter injection in FLOW3.</para>

        <note>
          <para>If both, a <methodname>set*</methodname> and a
          <methodname>inject*</methodname> method exist for the same property,
          the <methodname>inject*</methodname> method has precedence.</para>
        </note>

        <sidebar>
          <title>Constructor- or Setter Injection?</title>

          <para>The natural question which arises at this point is
          <quote>Should I use constructor- or setter injection?</quote>. There
          is no answer across-the-board – it mainly depends on the situation
          and your preferences. The authors of the Java-based <link
          xl:href="http://www.springframework.org">Spring Framework</link> for
          example prefer Setter Injection for its flexibility. The more
          puristic developers of <link
          xl:href="www.picocontainer.org">PicoContainer</link> strongly plead
          for using Constructor Injection for its cleaner approach. Reasons
          speaking in favor of constructor injections are:</para>

          <itemizedlist>
            <listitem>
              <para>Constructor Injection makes a stronger dependency
              contract</para>
            </listitem>

            <listitem>
              <para>It enforces a determinate state of the depending object:
              using setter Injection, the injected object is only available
              after the constructor has been called</para>
            </listitem>
          </itemizedlist>

          <para>However, there might be situations in which constructor
          injection is not possible or even cumbersome:</para>

          <itemizedlist>
            <listitem>
              <para>If an object has many dependencies and maybe even many
              optional dependencies, setter injection is a better
              solution.</para>
            </listitem>

            <listitem>
              <para>Subclasses are not always in control over the arguments
              passed to the constructor or might even be incapable of
              overriding the original constructor (FLOW3's action controller
              is such a case). Then setter injection is your only chance to
              get dependencies injected.</para>
            </listitem>

            <listitem>
              <para>Setter injection can be helpful to avoid circular
              dependencies between objects.</para>
            </listitem>

            <listitem>
              <para>Setters provide more flexibility to unit tests than a
              fixed set of constructor arguments</para>
            </listitem>
          </itemizedlist>
        </sidebar>
      </section>

      <section>
        <title>Property Injection</title>

        <para>Setter injection is the academic, clean way to set dependencies
        from outside. However, writing these setters can become quite tiresome
        if all they do is setting the property. For these cases FLOW3 provides
        support for <emphasis>Property Injection</emphasis>:</para>

        <example>
          <title>Example for Property Injection</title>

          <programlisting language="php">namespace F3\MyPackage;

class Foo {

	/**
	 * An instance of a BarInterface compatible object.
	 *
	 * @var \F3\MyPackage\BarInterface
	 * @inject
	 */
	protected $bar;

	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting>
        </example>

        <para>You could say that property injection is the same like setter
        injection – just without the setter. The <literal>@inject</literal>
        annotation tells the object framework that the property is supposed to
        be injected and the <literal>@var</literal> annotation specifies the
        type. Note that property injection even works (and should only be
        used) with protected properties. The Objects configuration for
        property injection is identical to the setter injection
        configuration.</para>

        <note>
          <para>If a setter method exists for the same property, it has
          precedence.</para>
        </note>

        <para>Setting properties directly, without a setter method, surely is
        convenient - but is it clean enough? In general it is a bad idea to
        allow direct access to mutable properties because you never know if at
        some point you need to take some action while a property is set. And
        if thousands of users (or only five) use your API, it's hard to change
        your design decision in favor of a setter method.</para>

        <para>However, we don't consider injection methods as part of the
        public API. As you've seen, FLOW3 takes care of all the object
        dependencies and the only other code working with injection methods
        directly are unit tests. Therefore we consider it safe to say that you
        can still switch back from property injection to setter injection
        without problems if it turns out that you really need it.</para>
      </section>

      <section>
        <title>Settings Injection</title>

        <para>No, this headline is not misspelled. FLOW3 offers some
        convenient feature which allows for automagically injecting the
        settings of the current package without the need to configure the
        injection. If a class contains a method called
        <methodname>injectSettings</methodname> and autowiring is not disabled
        for that object, the Object Builder will retrieve the settings of the
        package the object belongs to and pass it to the injectSettings
        method.</para>

        <example>
          <title>Example for the magic injectSettings method</title>

          <programlisting language="php">namespace F3\MyPackage;

class Foo {

	protected $settings = array();

	public function injectSettings(array $settings) {
		$this-&gt;settings = $settings;
	}

	public function doSomething() {
		var_dump($this-&gt;settings);
	}
}</programlisting>
        </example>

        <para>The <methodname>doSomething</methodname> method will output the
        settings of the <package>MyPackage</package> package.</para>
      </section>
    </section>

    <section>
      <title>Required and Optional Dependencies</title>

      <para>All dependencies defined in a constructor are, by its nature,
      required. If a dependency can't be solved by autowiring or by
      configuration, FLOW3's object builder will throw an exception.</para>

      <para>Also <emphasis>autowired setter-injected dependencies</emphasis>
      are, by default, required. There is a way to declare a setter-injected
      dependency as optional without the need to configure the dependency in a
      <filename>Objects</filename> configuration file. If an optional
      dependency can't be solved, it just won't be injected and it is the
      developer's responsibility to test for the availability of the desired
      object. FLOW3 uses the @optional annotation for this purpose:</para>

      <example>
        <title>Marking a setter-injected dependency as optional</title>

        <programlisting language="php">namespace F3\MyPackage;

/**
 * A very fooish class
 */
class Foo {

	/**
	 * @var \F3\MyPackage\BarInterface
	 */
	protected $bar;

	/**
	 * Injects a bar-ish object
	 *
	 * @param \F3\MyPackage\BarInterface $bar a kind of Bar object
	 * @return void
	 * @optional
	 */
	public function injectBar(\F3\MyPackage\BarInterface $bar) {
		$this-&gt;bar = $bar;
	}

	/**
	 * A method which does something
	 *
	 * @return void
	 */
	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting>
      </example>

      <para>Due to the @optional annotation, the injection of a
      <classname>Bar</classname> object is now no longer required. If the
      object builder can't autowire an object for this injection method, it
      will now no longer throw an exception.</para>
    </section>

    <section>
      <title>Dependency Resolution</title>

      <para>The dependencies between objects are only resolved during the
      instantiation process. Whenever a new instance of an object class needs
      to be created, the object configuration is checked for possible
      dependencies. If there is any, the required objects are built and only
      if all dependencies could be resolved, the object class is finally
      instantiated and the dependency injection takes place.</para>

      <para>During the resolution of dependencies it might happen that
      circular dependencies occur. If an object A requires an object B to be
      injected to its constructor and then again object B requires a object A
      likewise passed as a constructor argument, none of the two classes can
      be instantiated due to the mutual dependency. Although it is technically
      possible (albeit quite complex) to solve this type of reference, FLOW3's
      policy is not to allow circular dependencies at all. As a workaround you
      can use setter injection instead of Constructor Injection for either one
      or both of the objects causing the trouble.</para>
    </section>
  </section>

  <section xml:id="flow3.objectframework.configuringobjects">
    <title>Configuring objects</title>

    <para>The behavior of objects significantly depends on their
    configuration. During the initialization process all classes found in the
    various <filename>Classes/</filename> directories are registered as
    objects and an initial configuration is prepared. In a second step, other
    configuration sources are queried for additional configuration options.
    Definitions found at these sources are added to the base configuration in
    the following order:</para>

    <orderedlist>
      <listitem>
        <para>If they exist, the
        <filename><replaceable>PackageName</replaceable>/Configuration/Objects.*</filename>
        will be included.</para>
      </listitem>

      <listitem>
        <para>Additional configuration defined in the global
        <filename>Configuration/</filename> directory is applied.</para>
      </listitem>
    </orderedlist>

    <para>Currently there are three important situations in which you want to
    configure objects:</para>

    <itemizedlist>
      <listitem>
        <para>Override one object implementation with another</para>
      </listitem>

      <listitem>
        <para>Set the active implementation for an object type</para>
      </listitem>

      <listitem>
        <para>Explicitly define and configure dependencies to other
        objects</para>
      </listitem>
    </itemizedlist>

    <section>
      <title>Configuration Sources</title>

      <para>As already mentioned, the configuration for each object is
      compiled from different sources. The <filename>Objects.yaml</filename>
      file is the recommended format and is therefore used in most of the
      examples. However, the names of the configuration options and their
      possible values are identical to all configuration sources.</para>

      <section>
        <title>Objects.yaml</title>

        <para>If a file named <filename>Objects.yaml</filename> exists in the
        <filename>Configuration</filename> directory of a package, it will be
        included during the configuration process. The YAML file should stick
        to FLOW3's general rules for YAML-based configuration.</para>

        <example>
          <title>Sample Objects.yaml file</title>

          <programlisting language="yaml">#                                                                        #
# Object Configuration for the MyPackage package                         #
#                                                                        #

# @package MyPackage
# @version $Id: Objects.yaml 123 2009-01-01 12:00:00Z robert $

F3\MyPackage\Foo:
  arguments:
    1: { object: F3\MyPackage\Baz }
    2: { value: "some string" }
    3: { value: false }
  properties:
    bar: { object: F3\MyPackage\BarInterface }
    enableCache: { setting: MyPackage.Cache.enable }</programlisting>
        </example>
      </section>

      <section>
        <title>Objects.php</title>

        <para>As an alternative to YAML, it is possible to write configuration
        files in plain PHP. However, the PHP file should stick to FLOW3's
        general rules for PHP-based configuration.</para>

        <para>The following code again adds the same configuration as in the
        Constructor Injection example:</para>

        <example>
          <title>Sample Objects.php file</title>

          <programlisting language="php">&lt;?php
declare(ENCODING = 'utf-8');

/*                                                                        *
 * Object Configuration for the MyPackage package                         *
 * (this package doesn't really exist, and even if so, the configuration  *
 * would probably be different)                                           *
 *                                                                        */

$c['F3\MyPackage\Foo']-&gt;arguments-&gt;array(
	1 =&gt; array('object' =&gt; 'F3\MyPackage\Baz'),
	2 =&gt; array('value' =&gt; 'some string')
);

	// Demonstrates an alternative syntax:
$c['F3\MyPackage\Foo']-&gt;arguments-&gt;3-&gt;value = FALSE;

$c['F3\MyPackage\Foo']-&gt;properties-&gt;bar-&gt;object = 'F3\MyPackage\BarInterface';
$c['F3\MyPackage\Foo']-&gt;properties-&gt;enableCache-&gt;setting = ↩
    'MyPackage.Cache.enable';

?&gt;</programlisting>
        </example>

        <caution>
          <para>Only use these files for configuration, for example don't
          register autoloader methods in the <filename>Objects.php</filename>
          as this code must be invoked in an earlier stage.</para>
        </caution>
      </section>

      <section>
        <title>Annotations</title>

        <para>A very convenient way to configure certain aspects of objects
        are annotations. You write down the configuration directly where it
        takes effect: in the class file. However, this way of configuring
        objects is not really flexible, as it is hard coded. That's why only
        those options can be set through annotations which are part of the
        class design and won't change afterwards. Currently
        <literal>scope</literal> and <literal>inject</literal> are the only
        supported annotations.</para>

        <para>It's up to you defining the scope in the class directly or doing
        it in a <filename>Objects</filename> configuration file – both have
        the same effect. We recommend using annotations in this case, as the
        scope usually is a design decision which is very unlikely to be
        changed.</para>

        <example>
          <title>Sample scope annotation</title>

          <programlisting language="php">/**
 * This is my great class.
 *
 * @scope prototype
 */
class SomeClass {

}</programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>Overriding Object Implementations</title>

      <para>One advantage of componentry is the ability to replace objects by
      others without any bad impact on those parts depending on them. A
      prerequisite for replaceable objects is that their classes implement a
      common <link
      xl:href="http://www.php.net/manual/en/language.oop5.interfaces.php">interface</link>
      which defines the public API of the original object. Other objects which
      implement the same interface can then act as a true replacement for the
      original object without the need to change code anywhere in the system.
      If this requirement is met, the only necessary step to replace the
      original implementation with a substitute is to alter the object
      configuration and set the class name to the new implementation.</para>

      <para>To illustrate this circumstance, consider the following
      classes:</para>

      <example>
        <title>A simple Greeter class</title>

        <programlisting language="php">namespace F3\MyPackage;

class Greeter {
	public function sayHelloTo($name) {
		echo('Hello ' . $name);
	}
}</programlisting>
      </example>

      <para>During initialization the above class will automatically be
      registered as the object <classname>F3\MyPackage\Greeter</classname> and
      is available to other objects. In the class code of another object you
      might find these lines:</para>

      <example>
        <title>Code using the object F3_MyPackage_Greeter</title>

        <programlisting language="php">  // Use setter injection for fetching an instance 
  // of the \F3\MyPackage\Greeter object:
public function injectGreeter(\F3\MyPackage\Greeter $greeter) {
	$this-&gt;greeter = $greeter;
}

public function someAction() {
	$greeter-&gt;sayHelloTo('Heike');
}</programlisting>
      </example>

      <para>Great, that looks all fine and dandy but what if we want to use
      the much better object
      <classname>\F3\OtherPackage\GreeterWithCompliments</classname>? Well,
      you just configure the object
      <classname>\F3\MyPackage\Greeter</classname> to use a different
      class:</para>

      <example>
        <title>Objects.yaml file for object replacement</title>

        <programlisting language="yaml">  // Change the name of the class which
  // represents the object F3\MyPackage\Greeter
F3\MyPackage\Greeter: className: F3\OtherPackage\GreeterWithCompliments</programlisting>
      </example>

      <para>Now all objects who ask for a traditional greeter will get the
      more polite version. However, there comes a sour note with the above
      example: We can't be sure that the
      <classname>GreeterWithCompliments</classname> class really provides the
      necessary <function>sayHello()</function> method. The solution is to let
      both implementations implement the same interface:</para>

      <example>
        <title>The Greeter object type</title>

        <programlisting language="php">namespace F3\MyPackage;

interface GreeterInterface {
	public function sayHelloTo($name);
}

class Greeter implements \F3\MyPackage\GreeterInterface {
	public function sayHelloTo($name) {
		echo('Hello ' . $name);
	}
}

namespace F3\OtherPackage;

class GreeterWithCompliments implements \F3\MyPackage\GreeterInterface{
	public function sayHelloTo($name) {
		echo('Hello ' . $name . '! You look so great!');
	}
}</programlisting>
      </example>

      <para>Instead of referring to the original implementation directly we
      can now refer to the interface. In this case we call the object name a
      <emphasis>object type</emphasis> because it contains the name of a PHP
      interface.</para>

      <example>
        <title>Code using the object type
        F3\MyPackage\GreeterInterface</title>

        <programlisting language="php">  // Use setter injection for fetching an instance ↩
  // of the \F3\MyPackage\Greeter object:
public function injectGreeter(\F3\MyPackage\GreeterInterface $greeter) {
	$this-&gt;greeter = $greeter;
}

public function someAction() {
	$greeter-&gt;sayHelloTo('Heike');
}</programlisting>
      </example>

      <para>Finally we have to set which implementation of the
      <interfacename>F3\MyPackage\GreeterInterface</interfacename> should be
      active:</para>

      <example>
        <title>Objects.yaml file for object type definition</title>

        <para><programlisting language="yaml">F3\MyPackage\GreeterInterface:
  className: 'F3\OtherPackage\GreeterWithCompliments'</programlisting></para>
      </example>
    </section>

    <section>
      <title>Configuring Injection</title>

      <para>The object framework allows for injection of straight values,
      objects (i.e. dependencies) or settings either by passing them as
      constructor arguments during instantiation of the object class or by
      calling a setter method which sets the wished property accordingly. The
      necessary configuration for injecting objects is usually generated
      automatically by the <emphasis>autowiring</emphasis> capabilities of the
      Object Builder. Injection of straight values or settings, however,
      requires some explicit configuration.</para>

      <section>
        <title>Injection Values</title>

        <para>Regardless of what injection type is used (constructor or setter
        injection), there are three kinds of value which can be
        injected:</para>

        <itemizedlist>
          <listitem>
            <para><emphasis>value</emphasis>: static value of a simple type.
            Can be string, integer, boolean or array and is passed on as
            is.</para>
          </listitem>

          <listitem>
            <para><emphasis>object</emphasis>: name of an objects (or object
            type) which represents a dependency. Dependencies of the injected
            object are resolved and an instance of the object is passed
            along.</para>
          </listitem>

          <listitem>
            <para><emphasis>setting</emphasis>: setting defined in one of the
            <filename>Settings.*</filename> files. A path separated by dots
            "." specifies which setting to inject.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>Constructor Injection</title>

        <para>Arguments for constructor injection are defined through the
        <option>arguments</option> option. Each argument is identified by its
        position, counting starts with 1.</para>

        <example>
          <title>Sample class for Constructor Injection</title>

          <para><programlisting language="php">namespace F3\MyPackage;

class Foo {

	protected $bar;
	protected $identifier;
	protected $enableCache;

	public function __construct(\F3\MyPackage\BarInterface $bar, $identifier, ↩
    $enableCache) {
		$this-&gt;bar = $bar;
		$this-&gt;identifier = $identifier;
		$this-&gt;enableCache = $enableCache;
	}

	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting></para>
        </example>

        <example>
          <title>Sample configuration for Constructor Injection</title>

          <programlisting language="yaml">F3\MyPackage\Foo:
  arguments:
    1: { object: F3\MyPackage\Bar }
    2: { value: "some string" }
    3: { setting: "MyPackage.Cache.enable" }</programlisting>
        </example>

        <note>
          <para>It is usually not necessary to configure injection of objects
          explicitly. It is much more convent to just declare the type of the
          constructor arguments (like
          <interfacename>F3\MyPackage\BarInterface</interfacename> in the
          above example) and let the autowiring feature configure and resolve
          the dependencies for you.</para>
        </note>
      </section>

      <section>
        <title>Setter Injection</title>

        <para>The following class and the related
        <filename>Objects.yaml</filename> file demonstrate the syntax for the
        definition of setter injection:</para>

        <example>
          <title>Sample class for Setter Injection</title>

          <para><programlisting language="php">namespace F3\MyPackage;

class Foo {

	protected $bar;
	protected $identifier = 'Untitled';
	protected $enableCache = FALSE;

	public function injectBar(\F3\MyPackage\BarInterface $bar) {
		$this-&gt;bar = $bar;
	}

	public function setIdentifier($identifier) {
		$this-&gt;identifier = $identifier;
	}

	public function setEnableCache($enableCache) {
		$this-&gt;enableCache = $enableCache;
	}

	public function doSomething() {
		$this-&gt;bar-&gt;doSomethingElse();
	}
}</programlisting></para>
        </example>

        <example>
          <title>Sample configuration for Setter Injection</title>

          <programlisting language="yaml">F3\MyPackage\Foo:
  properties:
    bar: { object: F3\MyPackage\Bar }
    identifier: { value: "some string" }
    enableCache: { setting: "MyPackage.Cache.enable" }</programlisting>
        </example>

        <para>As you can see, it is important that a setter method with the
        same name as the property, preceded by "inject" or "set" exists. It
        doesn't matter though, if you choose "inject" or "set", except that
        "inject" has the advantage of being autowireable. As a rule of thumb
        we recommend using "inject" for required dependencies and values and
        "set" for optional properties.</para>
      </section>

      <section>
        <title>Injection of Objects Specified in Settings</title>

        <para>In some cases it might be convenient to specify the name of the
        object to be injected in the <emphasis>settings</emphasis> rather than
        in the objects configuration. This can be achieved by specifying the
        settings path instead of the object name:</para>

        <example>
          <title>Injecting an object specified in the settings</title>

          <programlisting language="yaml">F3\MyPackage\Foo:
  properties:
    bar: { object: MyPackage.fooStuff.barImplementation }</programlisting>
        </example>

        <example>
          <title>Example Settings.yaml of MyPackage</title>

          <programlisting language="yaml">fooStuff:
  barImplementation: F3\MyPackage\Bars\ASpecialBar</programlisting>
        </example>
      </section>

      <section>
        <title>Nested Object Configuration</title>

        <para>While autowiring and automatic dependency injection offers a
        great deal of convenience, it is sometimes necessary to have a fine
        grained control over which objects are injected with which third
        objects injected.</para>

        <para>Consider a FLOW3 cache object, a
        <classname>VariableCache</classname> for example: the cache itself
        depends on a cache backend which on its part requires a few settings
        passed to its constructor - this readily prepared cache should now be
        injected into another object. Sounds complex? With the objects
        configuration it is however possible to configure even that nested
        object structure:</para>

        <example>
          <title>Nesting object configuration</title>

          <programlisting language="yaml">F3\MyPackage\Controller\StandardController:
  properties:
    cache:
      object:
        name: F3\FLOW3\Cache\VariableCache
        arguments:
          1: value: MyCache
          2: 
            object:
              name: F3\FLOW3\Cache\Backend\File 
              properties:
                cacheDirectory: value: /tmp/</programlisting>
        </example>
      </section>

      <section>
        <title>Disabling Autowiring</title>

        <para>Injecting dependencies is a common task. Because FLOW3 can
        detect the type of dependencies a constructor needs, it automatically
        configures the object to ensure that the necessary objects are
        injected. This automation is called <firstterm>autowiring</firstterm>
        and is enabled by default for every object. As long as autowiring is
        in effect, the Object Builder will try to autowire all constructor
        arguments and all methods named after the pattern
        <methodname>inject*</methodname>.</para>

        <para>If, for some reason, autowiring is not wanted, it can be
        disabled by setting an option in the object configuration:</para>

        <example>
          <title>Turning off autowiring support in Objects.yaml</title>

          <programlisting language="yaml">F3\MyPackage\MyObject:
  autowiring: off;</programlisting>
        </example>
      </section>
    </section>

    <section>
      <title>Custom Factories</title>

      <para>Complex objects might require a custom factory which takes care of
      all important settings and dependencies. As we have seen previously, a
      cache consists of a frontend, a backend and configuration options for
      that backend. Instead of creating and configuring these objects on your
      own, you can use the <classname>F3\FLOW3\Cache\Factory</classname> which
      provides a convenient <methodname>create</methodname> method taking care
      of all the rest.</para>

      <programlisting language="php">$myCache = $cacheFactory-&gt;create('MyCache', 'F3\FLOW3\Cache\VariableCache', ↩
    'F3\FLOW3\Cache\Backend\File', array('cacheDirectory' =&gt; '/tmp'));</programlisting>

      <para>It is possible to specify for each object if it should be created
      by a custom factory rather than the Object Builder. Consider the
      following configuration:</para>

      <example>
        <title>Sample configuration for a Custom Factory</title>

        <programlisting language="yaml">F3\FLOW3\Cache\CacheInterface:
  factoryClassName: F3\FLOW3\Cache\Factory
  factoryMethodName: create</programlisting>
      </example>

      <para>From now on the Cache Factory's <methodname>create</methodname>
      method will be called each time an object of type
      <classname>CacheInterface</classname> needs to be instantiated. If
      arguments were passed to the <methodname>getObject</methodname> or
      <methodname>create</methodname> method, they will be passed through to
      the custom factory method:</para>

      <example>
        <title>YAML configuration for a Custom Factory with default
        arguments</title>

        <programlisting language="yaml">F3\FLOW3\Cache\CacheInterface:
  factoryClassName: F3\FLOW3\Cache\Factory
  arguments:
    2: value: F3\FLOW3\Cache\VariableCache
    3: value: F3\FLOW3\Cache\Backend\File
    4: value: { cacheDirectory: /tmp }</programlisting>
      </example>

      <example>
        <title>PHP code using the custom factory</title>

        <programlisting language="php">$myCache = $objectFactory-&gt;create('MyCache');</programlisting>
      </example>

      <para><varname>$objectFactory</varname> is a reference to the
      <classname>F3\FLOW3\Object\Factory</classname>. The argument with the
      value <literal>MyCache</literal> is passed to the Cache Factory as the
      first parameter. The required second and third argument and the optional
      fourth parameter are automatically built from the values defined in the
      object configuration.</para>
    </section>

    <section>
      <title>Name of Lifecycle Methods</title>

      <para>The default name of a lifecycle methods is
      <methodname>initializeObject</methodname> and
      <methodname>shutdownObject</methodname>. If these methods exist, the
      initialization method will be called after the object has been
      instantiated and all dependencies are injected and the shutdown method
      is called before the Object Manager quits its service. The name of both
      methods is configurable per object for situations you don't have control
      over the name of your initialization method (maybe, because you are
      integrating legacy code):</para>

      <example>
        <title>Objects.yaml configuration of the initialization and shutdown
        method</title>

        <programlisting language="yaml">F3\MyPackage\MyObject:
  lifecycleInitializationMethod: myInitializeMethodname
  lifecycleShutdownMethod: myShutdownMethodname</programlisting>
      </example>
    </section>
  </section>
</chapter>
